name: 'check'
description: 'Performs check'
inputs:
  check:
    required: true
    description: 'Check to be performed. Value to be provided in scheme:input format where scheme can be - npm, compose.'
  image:
    required: true
    description: 'Image against which check will be performed'
  docker_registry:
    required: true
    description: 'Docker registry where build images would be pushed and pulled from'
  docker_username:
    required: true
    description: 'Username for authenticating with provided docker registry'
  docker_password:
    required: true
    description: 'Password for authenticating with provided docker registry'
  tag:
    required: false
    description: 'If provided, can be used for tagging the image'
  deploy_annotate_pr:
        required: false
        type: boolean
        description: 'Enable pull request annotation with deployment URL. Requires pull_request_number to work.'
        default: true
  pull_request_number:
        required: false
        type: number
        description: 'Pull request number running the workflow against a pull request'
runs:
  using: composite
  steps:
    - name: Process check
      id: check
      shell: bash
      env:
        CHECK: ${{ inputs.check }}
      run: |
        echo "::set-output name=scheme::${CHECK%:*}"
        echo "::set-output name=input::${CHECK#*:}"

    - name: Docker setup
      uses: docker/setup-buildx-action@v2

    - name: Docker login
      uses: docker/login-action@v2
      with:
        registry: ${{ inputs.docker_registry }}
        username: ${{ inputs.docker_username }}
        password: ${{ inputs.docker_password }}

    - name: Docker pull
      shell: bash
      run: |
        docker pull ${{ inputs.image }}
        docker tag ${{ inputs.image }} ${{ inputs.tag }}

    - name: Run Docker Compose
      run: |
      # Replace 'app/docker-compose.${{ steps.check.outputs.input }}.yml' with your Docker Compose file path
      docker-compose -f app/docker-compose.${{ steps.check.outputs.input }}.yml up --detach

      # Wait for the container to start (adjust the sleep duration if needed)
      sleep 10

      # Get the text file from the running container (replace 'file.txt' with your file name)
      ls
      docker cp $(docker-compose ps -q app):coverage-summary.txt .

      # Stop and remove the containers created by Docker Compose
      docker-compose -f app/docker-compose.${{ steps.check.outputs.input }}.yml down
          
    - uses: marocchino/sticky-pull-request-comment@v2
        # only run this step if enabled and pull request number was provided
        if: inputs.deploy_annotate_pr == true && inputs.pull_request_number
        with:
          header: ${{ inputs.app_name }}
          hide_and_recreate: true
          hide_classify: "OUTDATED"
          number: ${{ inputs.pull_request_number }}
          message: |
            ${{ cat coverage-summary.txt }}

    # runs check using npm
    # for a check - npm:lint
    # will execute - npm run lint

    - name: Run check using npm
      if: steps.check.outputs.scheme == 'npm'
      shell: bash
      run: |
        docker run -t ${{ inputs.image }} npm run ${{ steps.check.outputs.input }}

    # runs check using docker compose
    # for a check - compose:test
    # will look for compose file - docker-compose.test.yml and will run the services.
    # service named 'app' should run and exit successfully to mark the test successful
    # to reference the app's image, inputs.tag can be used

    - name: Run check using compose
      if: steps.check.outputs.scheme == 'compose'
      shell: bash
      run: |
        
        docker-compose -f app/docker-compose.${{ steps.check.outputs.input }}.yml up --exit-code-from app

    # - name: Run check using compose for code coverage
    #   if: steps.check.outputs.scheme == 'coverage'
    #   shell: bash
    #   run: |
    #     docker-compose -f app/docker-compose.${{ steps.check.outputs.scheme }}.yml up --exit-code-from app 
      
    # - name: Extract coverage information
    #   if: steps.check.outputs.input == 'coverage'
    #   id: extract_coverage
    #   run: |
    #     coverage_percentage=$(grep -oP "(?<=Statements\s+:)\s+\d+\.\d+" coverage-summary.txt)
    #     echo "::set-output name=coverage_percentage::$coverage_percentage"

    # - uses: tintef/nyc-reporter-action
    #   with:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #     REPORTER: 'text' # defaults to 'text-summary'
    
    # - uses: marocchino/sticky-pull-request-comment@v2
    #     # only run this step if enabled and pull request number was provided
    #     if: inputs.deploy_annotate_pr == true && inputs.pull_request_number
    #     with:
    #       header: ${{ inputs.app_name }}
    #       hide_and_recreate: true
    #       hide_classify: "OUTDATED"
    #       number: ${{ inputs.pull_request_number }}
    #       message: |
    #         Test Coverage ${{ steps.extract_coverage.outputs.coverage_percentage }}

    # - name: Post coverage report as a comment
    #   if: steps.check.outputs.input == 'coverage'
    #   uses: actions/github-script@v4
    #   with:
    #     script: |
    #       const context = github.context;
    #       const prNumber = context.payload.pull_request.number;
    #       const coveragePercentage = '${{ steps.extract_coverage.outputs.coverage_percentage }}';

    #       const message = `Test Coverage: ${coveragePercentage}%`;
    #       const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

    #       octokit.issues.createComment({
    #         owner: context.repo.owner,
    #         repo: context.repo.repo,
    #         issue_number: prNumber,
    #         body: message,
    #       });
