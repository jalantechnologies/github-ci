name: 'deploy'
description: 'Deploy application to Kubernetes'
inputs:
  app_name:
    required: true
    description: 'Application name based on which docker repository, doppler project and kube namespace would be selected'
  app_env:
    required: true
    description: 'Application environment based on which doppler configuration, kube namespace and kube spec files would be selected'
  app_hostname:
    required: true
    description: 'Application hostname where application would be deployed. Available placeholders - {0} Provided application environment, {1} Branch ID generated from provided branch'
  aws_access_key_id:
    required: false
    description: 'Access key ID for AWS'
  aws_secret_access_key:
    required: false
    description: 'Access key Secret for AWS'
  aws_cluster_name:
    required: false
    description: 'AWS EKS Cluster name'
  aws_region:
    required: false
    description: 'Region for AWS. Defaults to us-east-1.'
    default: 'us-east-1'
  branch:
    required: true
    description: 'Branch from which this action was run'
  deploy_id:
    required: false
    description: 'Unique identifier which can also be used for giving priority to resources created during deployment process'
  deploy_root:
    required: true
    description: 'Directory where kube deployment would look for kubernetes specification files'
  deploy_labels:
    required: false
    description: 'Can be used for tagging kube resources created during deployment process'
  deploy_image:
    required: true
    description: 'Docker image to use for deployment'
  docker_registry:
    required: false
    description: 'Docker registry where build images would be pushed and pulled from'
  docker_username:
    required: false
    description: 'Username for authenticating with provided docker registry'
  docker_password:
    required: false
    description: 'Password for authenticating with provided docker registry'
  do_access_token:
    required: false
    description: 'DigitalOcean access token'
  do_cluster_id:
    required: false
    description: 'Kubernetes cluster ID on DigitalOcean'
  doppler_token:
    required: false
    description: 'Doppler token for accessing environment variables'
  pull_request_number:
    required: false
    description: 'Pull request number running the workflow against a pull request'
  deploy_annotate_pr:
    required: false
    description: 'Enable pull request annotation with deployment URL. Requires pull_request_number to work.'

outputs:
  url:
    description: 'URL where application has been deployed'
    value: ${{ steps.deploy.outputs.url }}
  temporal_dashboard_url:
    description: 'URL for Temporal Dashboard'
    value: ${{ steps.temporal.outputs.temporal_dashboard_url }}

runs:
  using: composite
  steps:
    - name: Extract branch name
      id: extract_branch
      shell: bash
      run: |
        BRANCH_NAME=$(echo ${{ inputs.branch }} | sed -e 's/^refs\/heads\///g')
        BRANCH_HASH=$(sha1sum < <(printf '%s' $BRANCH_NAME) | cut -c -15)

        echo "branch=$(echo $BRANCH_NAME)" >> $GITHUB_OUTPUT
        echo "branch_hash=$(echo $BRANCH_HASH)" >> $GITHUB_OUTPUT
        echo "branch_commit_hash=$(echo $GITHUB_SHA)" >> $GITHUB_OUTPUT
        echo "branch_actor=$(echo $GITHUB_ACTOR)" >> $GITHUB_OUTPUT

    - name: DigitalOcean setup
      env:
        DO_ACCESS_TOKEN: ${{ inputs.do_access_token }}
      if: "${{ env.DO_ACCESS_TOKEN != '' }}"
      with:
        token: ${{ inputs.do_access_token }}
      uses: digitalocean/action-doctl@v2

    - name: DigitalOcean Kubernetes setup
      shell: bash
      env:
        DO_CLUSTER_ID: ${{ inputs.do_cluster_id }}
      if: "${{ env.DO_CLUSTER_ID != '' }}"
      run: doctl kubernetes cluster kubeconfig save $DO_CLUSTER_ID

    - name: AWS setup
      uses: aws-actions/configure-aws-credentials@v1
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.aws_access_key_id }}
      if: "${{ env.AWS_ACCESS_KEY_ID != '' }}"
      with:
        aws-access-key-id: ${{ inputs.aws_access_key_id }}
        aws-secret-access-key: ${{ inputs.aws_secret_access_key }}
        aws-region: ${{ inputs.aws_region }}
        mask-aws-account-id: 'false'

    - name: AWS Kubernetes setup
      shell: bash
      env:
        AWS_CLUSTER_NAME: ${{ inputs.aws_cluster_name }}
        AWS_REGION: ${{ inputs.aws_region }}
      if: "${{ env.AWS_CLUSTER_NAME != '' }}"
      run: aws eks update-kubeconfig --name $AWS_CLUSTER_NAME --region $AWS_REGION

    - name: Kubernetes deploy
      shell: bash
      id: deploy
      # kube configurations can use following environment variables along with the default ones provided by GitHub action
      # https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
      env:
        DOCKER_REGISTRY: ${{ inputs.docker_registry }}
        DOCKER_USERNAME: ${{ inputs.docker_username }}
        DOCKER_PASSWORD: ${{ inputs.docker_password }}
        DOPPLER_TOKEN: ${{ inputs.doppler_token }}
        DOPPLER_TOKEN_SECRET_NAME: doppler-${{ inputs.app_name }}-${{ inputs.app_env }}-token-secret
        DOPPLER_MANAGED_SECRET_NAME: doppler-${{ inputs.app_name }}-${{ inputs.app_env }}-managed-secret
        KUBE_ROOT: ${{ inputs.deploy_root }}
        KUBE_NS: ${{ inputs.app_name }}-${{ inputs.app_env }}
        KUBE_APP: ${{ inputs.app_name }}-${{ inputs.app_env }}-${{ steps.extract_branch.outputs.branch_hash }}
        KUBE_ENV: ${{ inputs.app_env }}
        KUBE_DEPLOYMENT_IMAGE: ${{ inputs.deploy_image }}
        KUBE_INGRESS_HOSTNAME: ${{ format(inputs.app_hostname, inputs.app_env, steps.extract_branch.outputs.branch_hash) }}
        KUBE_LABELS: gh/actor=${{ steps.extract_branch.outputs.branch_actor }} gh/commit=${{ steps.extract_branch.outputs.branch_commit_hash }} ${{ inputs.deploy_labels }}
        KUBE_DEPLOY_ID: ${{ inputs.deploy_id }}
      run: |
        source platform/lib/kube/deploy.sh
        echo "url=https://$KUBE_INGRESS_HOSTNAME" >> $GITHUB_OUTPUT
        echo "temporal_dashboard_url=https://$KUBE_INGRESS_WORKER_HOSTNAME" >> $GITHUB_OUTPUT

    - name: Extract and format Temporal Dashboard URL
      id: temporal
      shell: bash
      run: |
        full_url="${{ steps.deploy.outputs.url }}"
        domain="${full_url#*://}"
        first_label="${domain%%.*}"
        rest="${domain#*.}"
        temporal_dashboard_url="https://${first_label}.workers-dashboard.${rest}"
        echo "temporal_dashboard_url=${temporal_dashboard_url}" >> $GITHUB_OUTPUT

    - name: Show diagnostics in logs
      if: failure()
      shell: bash
      run: |
        echo "===== K8s Diagnostics (raw) ====="
        if [ -d ci_artifacts ]; then
          while IFS= read -r -d '' f; do
            echo "::group::${f}"
            cat "$f" || true
            echo "::endgroup::"
          done < <(find ci_artifacts -type f -print0 | sort -z)
        else
          echo "No diagnostics found."
        fi

    - name: Comment diagnostics summary on PR
      if: always() && github.event_name == 'pull_request'
      uses: marocchino/sticky-pull-request-comment@v2
      with:
        path: ci_artifacts/summary.md
        header: diagnostics-summary
        hide_and_recreate: true
        hide_classify: "OUTDATED"
    

    - name: Comment deployment URLs on PR
      if: ${{ inputs.deploy_annotate_pr == 'true' && inputs.pull_request_number != '' }}
      uses: marocchino/sticky-pull-request-comment@v2
      with:
        header: ${{ inputs.app_name }}
        hide_and_recreate: true
        hide_classify: "OUTDATED"
        number: ${{ inputs.pull_request_number }}
        message: |
          Deployment (${{ inputs.app_name }}) is available:
          Web App: ${{ steps.deploy.outputs.url }}
          Workers Dashboard: ${{ steps.temporal.outputs.temporal_dashboard_url }}